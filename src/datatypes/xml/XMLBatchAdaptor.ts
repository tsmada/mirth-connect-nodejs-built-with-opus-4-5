/**
 * Ported from: ~/Projects/connect/server/src/com/mirth/connect/plugins/datatypes/xml/XMLBatchAdaptor.java
 *
 * Purpose: Splits XML batch messages into individual sub-messages using one of four methods:
 *   - Element_Name: Find all elements with a given local name at any depth
 *   - Level: Extract elements at a specified nesting depth (root = level 0)
 *   - XPath_Query: Simple path-based element selection (e.g., /root/child)
 *   - JavaScript: Delegate to ScriptBatchAdaptor for script-based splitting
 *
 * Key behaviors:
 *   - Java uses javax.xml.xpath for Element_Name, Level, and XPath_Query modes
 *   - Element_Name generates XPath: //*[local-name()='elementName']
 *   - Level generates XPath with (level+1) wildcard steps
 *   - XPath_Query passes the user-provided query directly
 *   - JavaScript mode delegates to the batch script engine
 *   - Output omits XML declaration (matches Java's OMIT_XML_DECLARATION=yes)
 */

import { XMLParser, XMLBuilder } from 'fast-xml-parser';
import type { BatchAdaptor, BatchAdaptorFactory } from '../../donkey/message/BatchAdaptor.js';
import { ScriptBatchAdaptor, type ScriptBatchReader } from '../../donkey/message/ScriptBatchAdaptor.js';

export enum XMLSplitType {
  Element_Name = 'Element_Name',
  Level = 'Level',
  XPath_Query = 'XPath_Query',
  JavaScript = 'JavaScript',
}

export interface XMLBatchProperties {
  splitType: XMLSplitType;
  elementName?: string;
  level?: number;
  xpathQuery?: string;
  batchScript?: string;
}

// Parser config: preserves order, attributes, CDATA, and text nodes
const PARSER_OPTIONS = {
  ignoreAttributes: false,
  attributeNamePrefix: '@_',
  preserveOrder: true,
  cdataPropName: '__cdata',
  textNodeName: '#text',
  trimValues: false,
};

const BUILDER_OPTIONS = {
  ignoreAttributes: false,
  attributeNamePrefix: '@_',
  preserveOrder: true,
  cdataPropName: '__cdata',
  textNodeName: '#text',
  format: true,
  suppressEmptyNode: false,
};

/**
 * Recursively collect all elements with the given local name from the parsed tree.
 * fast-xml-parser's preserveOrder format uses arrays of objects where each object
 * has a single key (the element tag name) with array children.
 */
function findElementsByName(nodes: any[], name: string): any[] {
  const results: any[] = [];

  for (const node of nodes) {
    for (const key of Object.keys(node)) {
      if (key === ':@' || key === '#text' || key === '__cdata') continue;

      // Check if this element matches the name (ignoring namespace prefix)
      const localName = key.includes(':') ? key.split(':').pop()! : key;
      if (localName === name) {
        results.push(node);
      }

      // Recurse into children
      if (Array.isArray(node[key])) {
        results.push(...findElementsByName(node[key], name));
      }
    }
  }

  return results;
}

/**
 * Extract elements at a given depth level from the parsed tree.
 * Java's Level mode: root = level 0, direct children of root = level 1, etc.
 * The XPath generated by Java has (level + 1) wildcard steps.
 * The first wildcard matches the root, so level 0 = root element itself (the entire document),
 * level 1 = children of root, level 2 = grandchildren of root, etc.
 */
function findElementsByLevel(nodes: any[], targetLevel: number): any[] {
  if (targetLevel < 0) return [];

  const results: any[] = [];

  function traverse(currentNodes: any[], currentLevel: number): void {
    for (const node of currentNodes) {
      for (const key of Object.keys(node)) {
        if (key === ':@' || key === '#text' || key === '__cdata') continue;

        if (currentLevel === targetLevel) {
          results.push(node);
        } else if (Array.isArray(node[key])) {
          traverse(node[key], currentLevel + 1);
        }
      }
    }
  }

  traverse(nodes, 0);
  return results;
}

/**
 * Evaluate a simple XPath-like path expression against the parsed tree.
 * Supports paths like:
 *   /root/child         - absolute path to named elements
 *   /root/*             - wildcard children
 *   //elementName       - descendant search (delegates to findElementsByName)
 *
 * For complex XPath (predicates, axes, functions), throws a descriptive error.
 */
function evaluateSimpleXPath(nodes: any[], xpath: string): any[] {
  const trimmed = xpath.trim();

  // Descendant-or-self shortcut: //name
  if (trimmed.startsWith('//')) {
    const name = trimmed.substring(2);
    if (!name || /[[\]@()=|,]/.test(name)) {
      throw new Error(
        `Unsupported XPath query: "${xpath}". Complex XPath expressions with predicates, axes, or functions ` +
          `are not supported. Use Element_Name or Level split mode instead.`
      );
    }
    return findElementsByName(nodes, name);
  }

  // Must start with /
  if (!trimmed.startsWith('/')) {
    throw new Error(
      `XPath query must start with "/": "${xpath}". Use an absolute path like "/root/child".`
    );
  }

  // Check for unsupported features
  if (/[[\]@()=|,]/.test(trimmed)) {
    throw new Error(
      `Unsupported XPath query: "${xpath}". Complex XPath expressions with predicates, axes, or functions ` +
        `are not supported. Use Element_Name or Level split mode instead.`
    );
  }

  // Split path into segments: /root/child/item â†’ ['root', 'child', 'item']
  const segments = trimmed.split('/').filter((s) => s.length > 0);
  if (segments.length === 0) return [];

  let current = nodes;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i]!;
    const isLast = i === segments.length - 1;
    const matched: any[] = [];

    for (const node of current) {
      for (const key of Object.keys(node)) {
        if (key === ':@' || key === '#text' || key === '__cdata') continue;

        const localName = key.includes(':') ? key.split(':').pop()! : key;
        if (segment === '*' || localName === segment) {
          if (isLast) {
            matched.push(node);
          } else if (Array.isArray(node[key])) {
            matched.push(...node[key]);
          }
        }
      }
    }

    if (isLast) {
      return matched;
    }
    current = matched;
  }

  return [];
}

export class XMLBatchAdaptor implements BatchAdaptor {
  private messages: string[];
  private index: number = 0;
  private sequenceId: number = 0;

  // For JavaScript mode, delegate to ScriptBatchAdaptor
  private scriptAdaptor: ScriptBatchAdaptor | null = null;

  constructor(
    rawMessage: string,
    properties: XMLBatchProperties,
    batchScriptFn?: (context: {
      reader: ScriptBatchReader;
      sourceMap: Map<string, unknown>;
    }) => string | null,
    sourceMap?: Map<string, unknown>
  ) {
    if (properties.splitType === XMLSplitType.JavaScript) {
      if (!batchScriptFn) {
        throw new Error('No batch script was set.');
      }
      this.scriptAdaptor = new ScriptBatchAdaptor(rawMessage, batchScriptFn, sourceMap);
      this.messages = [];
    } else {
      this.messages = this.splitMessages(rawMessage, properties);
    }
  }

  private splitMessages(rawMessage: string, properties: XMLBatchProperties): string[] {
    if (!rawMessage || rawMessage.trim().length === 0) {
      return [];
    }

    const parser = new XMLParser(PARSER_OPTIONS);
    const builder = new XMLBuilder(BUILDER_OPTIONS);

    let parsed: any[];
    try {
      parsed = parser.parse(rawMessage);
    } catch {
      // If XML is malformed, return the raw message as a single item
      return [rawMessage];
    }

    if (!Array.isArray(parsed) || parsed.length === 0) {
      return [rawMessage];
    }

    let matchedNodes: any[];

    switch (properties.splitType) {
      case XMLSplitType.Element_Name: {
        const name = properties.elementName ?? '';
        if (!name) return [rawMessage];
        matchedNodes = findElementsByName(parsed, name);
        break;
      }

      case XMLSplitType.Level: {
        const level = properties.level ?? 1;
        matchedNodes = findElementsByLevel(parsed, level);
        break;
      }

      case XMLSplitType.XPath_Query: {
        const query = properties.xpathQuery ?? '';
        if (!query) return [rawMessage];
        matchedNodes = evaluateSimpleXPath(parsed, query);
        break;
      }

      default:
        throw new Error(`No valid batch splitting method configured: ${properties.splitType}`);
    }

    if (matchedNodes.length === 0) {
      return [];
    }

    // Serialize each matched node back to XML (without XML declaration, matching Java)
    return matchedNodes.map((node) => {
      const xml = builder.build([node]) as string;
      return xml.trim();
    });
  }

  async getMessage(): Promise<string | null> {
    if (this.scriptAdaptor) {
      return this.scriptAdaptor.getMessage();
    }

    if (this.index >= this.messages.length) {
      return null;
    }
    this.sequenceId = this.index + 1;
    return this.messages[this.index++]!;
  }

  getBatchSequenceId(): number {
    if (this.scriptAdaptor) {
      return this.scriptAdaptor.getBatchSequenceId();
    }
    return this.sequenceId;
  }

  isBatchComplete(): boolean {
    if (this.scriptAdaptor) {
      return this.scriptAdaptor.isBatchComplete();
    }
    return this.index >= this.messages.length;
  }

  cleanup(): void {
    if (this.scriptAdaptor) {
      this.scriptAdaptor.cleanup();
      return;
    }
    this.messages = [];
    this.index = 0;
    this.sequenceId = 0;
  }
}

export class XMLBatchAdaptorFactory implements BatchAdaptorFactory {
  private properties: XMLBatchProperties;
  private batchScriptFn?: (context: {
    reader: ScriptBatchReader;
    sourceMap: Map<string, unknown>;
  }) => string | null;
  private sourceMap?: Map<string, unknown>;

  constructor(
    properties: XMLBatchProperties,
    batchScriptFn?: (context: {
      reader: ScriptBatchReader;
      sourceMap: Map<string, unknown>;
    }) => string | null,
    sourceMap?: Map<string, unknown>
  ) {
    this.properties = properties;
    this.batchScriptFn = batchScriptFn;
    this.sourceMap = sourceMap;
  }

  createBatchAdaptor(rawMessage: string): XMLBatchAdaptor {
    return new XMLBatchAdaptor(rawMessage, this.properties, this.batchScriptFn, this.sourceMap);
  }
}
