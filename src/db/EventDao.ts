/**
 * Event Data Access Object
 *
 * Ported from: ~/Projects/connect/server/dbconf/mysql/mysql-event.xml
 *
 * Handles CRUD operations for the EVENT table (audit log).
 *
 * Key behaviors:
 * - ID is auto-generated by database
 * - Results ordered by ID DESC (newest first)
 * - Attributes serialized as key=value pairs
 * - All date comparisons are inclusive
 */

import { query, execute } from './pool.js';
import {
  ServerEvent,
  EventFilter,
  EventLevel,
  EventOutcome,
  attributesToObject,
} from '../api/models/ServerEvent.js';
import { RowDataPacket } from 'mysql2';

// ============================================================================
// Database Row Interface
// ============================================================================

interface EventRow extends RowDataPacket {
  ID: number;
  DATE_CREATED: Date;
  NAME: string;
  EVENT_LEVEL: string;
  OUTCOME: string;
  ATTRIBUTES: string | null;
  USER_ID: number;
  IP_ADDRESS: string | null;
  SERVER_ID: string;
}

interface MaxIdRow extends RowDataPacket {
  max_id: number | null;
}

interface CountRow extends RowDataPacket {
  count: number;
}

// ============================================================================
// Serialization Helpers
// ============================================================================

/**
 * Serialize attributes Map to database format
 * Format: key1=value1\nkey2=value2
 */
function serializeAttributes(attributes: Map<string, string>): string | null {
  if (attributes.size === 0) {
    return null;
  }
  const lines: string[] = [];
  for (const [key, value] of attributes) {
    // Escape newlines in values
    const escapedValue = value.replace(/\n/g, '\\n').replace(/=/g, '\\=');
    lines.push(`${key}=${escapedValue}`);
  }
  return lines.join('\n');
}

/**
 * Deserialize attributes from database format
 */
function deserializeAttributes(text: string | null): Map<string, string> {
  const map = new Map<string, string>();
  if (!text) {
    return map;
  }
  const lines = text.split('\n');
  for (const line of lines) {
    const eqIndex = line.indexOf('=');
    if (eqIndex > 0) {
      const key = line.substring(0, eqIndex);
      let value = line.substring(eqIndex + 1);
      // Unescape
      value = value.replace(/\\n/g, '\n').replace(/\\=/g, '=');
      map.set(key, value);
    }
  }
  return map;
}

/**
 * Convert database row to ServerEvent
 */
function rowToEvent(row: EventRow): ServerEvent {
  return {
    id: row.ID,
    eventTime: new Date(row.DATE_CREATED),
    name: row.NAME,
    level: row.EVENT_LEVEL as EventLevel,
    outcome: row.OUTCOME as EventOutcome,
    attributes: deserializeAttributes(row.ATTRIBUTES),
    userId: row.USER_ID,
    ipAddress: row.IP_ADDRESS,
    serverId: row.SERVER_ID,
  };
}

// ============================================================================
// CRUD Operations
// ============================================================================

/**
 * Insert a new event
 * @returns The auto-generated event ID
 */
export async function insertEvent(event: Omit<ServerEvent, 'id'>): Promise<number> {
  const result = await execute(
    `INSERT INTO EVENT (NAME, EVENT_LEVEL, OUTCOME, ATTRIBUTES, USER_ID, IP_ADDRESS, SERVER_ID, DATE_CREATED)
     VALUES (:name, :level, :outcome, :attributes, :userId, :ipAddress, :serverId, :eventTime)`,
    {
      name: event.name,
      level: event.level,
      outcome: event.outcome,
      attributes: serializeAttributes(event.attributes),
      userId: event.userId,
      ipAddress: event.ipAddress,
      serverId: event.serverId,
      eventTime: event.eventTime,
    }
  );
  return result.insertId;
}

/**
 * Get event by ID
 */
export async function getEventById(id: number): Promise<ServerEvent | null> {
  const rows = await query<EventRow>('SELECT * FROM EVENT WHERE ID = :id', { id });
  if (rows.length === 0) {
    return null;
  }
  return rowToEvent(rows[0]!);
}

/**
 * Get maximum event ID
 */
export async function getMaxEventId(): Promise<number> {
  const rows = await query<MaxIdRow>('SELECT MAX(ID) as max_id FROM EVENT');
  return rows[0]?.max_id ?? 0;
}

/**
 * Search events with filter
 */
export async function searchEvents(
  filter: EventFilter,
  offset?: number,
  limit?: number
): Promise<ServerEvent[]> {
  const { sql, params } = buildSearchQuery(filter, false);

  let fullSql = sql + ' ORDER BY ID DESC';
  if (limit !== undefined) {
    fullSql += ` LIMIT ${limit}`;
  }
  if (offset !== undefined) {
    fullSql += ` OFFSET ${offset}`;
  }

  const rows = await query<EventRow>(fullSql, params);
  return rows.map(rowToEvent);
}

/**
 * Count events matching filter
 */
export async function countEvents(filter: EventFilter): Promise<number> {
  const { sql, params } = buildSearchQuery(filter, true);
  const rows = await query<CountRow>(sql, params);
  return rows[0]?.count ?? 0;
}

/**
 * Remove all events
 * Uses TRUNCATE for performance and to reset auto-increment
 */
export async function removeAllEvents(): Promise<void> {
  await execute('TRUNCATE TABLE EVENT');
}

/**
 * Delete events older than a given date threshold
 * Used by the Data Pruner to clean up old audit log entries.
 * @returns The number of events deleted
 */
export async function deleteEventsBeforeDate(dateThreshold: Date): Promise<number> {
  const result = await execute('DELETE FROM EVENT WHERE DATE_CREATED < :dateThreshold', {
    dateThreshold,
  });
  return result.affectedRows;
}

/**
 * Get all events for export
 */
export async function getAllEvents(): Promise<ServerEvent[]> {
  const rows = await query<EventRow>('SELECT * FROM EVENT ORDER BY ID DESC');
  return rows.map(rowToEvent);
}

// ============================================================================
// Query Builder
// ============================================================================

interface QueryResult {
  sql: string;
  params: Record<string, unknown>;
}

/**
 * Build search query with dynamic WHERE clauses
 *
 * Replicates MySQL MyBatis behavior:
 * - All conditions are ANDed
 * - Date comparisons are inclusive (>= and <=)
 * - Name search is case-insensitive LIKE
 * - Server ID uses partial LIKE match
 */
function buildSearchQuery(filter: EventFilter, countOnly: boolean): QueryResult {
  const conditions: string[] = [];
  const params: Record<string, unknown> = {};

  if (filter.maxEventId !== undefined) {
    conditions.push('ID <= :maxEventId');
    params.maxEventId = filter.maxEventId;
  }

  if (filter.minEventId !== undefined) {
    conditions.push('ID >= :minEventId');
    params.minEventId = filter.minEventId;
  }

  if (filter.id !== undefined) {
    conditions.push('ID = :id');
    params.id = filter.id;
  }

  if (filter.name !== undefined && filter.name.trim() !== '') {
    conditions.push('LOWER(NAME) LIKE LOWER(:nameLike)');
    params.nameLike = `%${filter.name}%`;
  }

  if (filter.levels !== undefined && filter.levels.length > 0) {
    // Build IN clause with positional placeholders
    const levelPlaceholders = filter.levels.map((_, i) => `:level${i}`);
    conditions.push(`EVENT_LEVEL IN (${levelPlaceholders.join(', ')})`);
    filter.levels.forEach((level, i) => {
      params[`level${i}`] = level;
    });
  }

  if (filter.startDate !== undefined) {
    conditions.push('DATE_CREATED >= :startDate');
    params.startDate = filter.startDate;
  }

  if (filter.endDate !== undefined) {
    conditions.push('DATE_CREATED <= :endDate');
    params.endDate = filter.endDate;
  }

  if (filter.outcome !== undefined) {
    conditions.push('OUTCOME = :outcome');
    params.outcome = filter.outcome;
  }

  if (filter.userId !== undefined) {
    conditions.push('USER_ID = :userId');
    params.userId = filter.userId;
  }

  if (filter.ipAddress !== undefined && filter.ipAddress.trim() !== '') {
    conditions.push('IP_ADDRESS = :ipAddress');
    params.ipAddress = filter.ipAddress;
  }

  if (filter.serverId !== undefined && filter.serverId.trim() !== '') {
    conditions.push('SERVER_ID LIKE :serverIdLike');
    params.serverIdLike = `%${filter.serverId}%`;
  }

  const selectClause = countOnly ? 'SELECT COUNT(*) as count' : 'SELECT *';
  let sql = `${selectClause} FROM EVENT`;

  if (conditions.length > 0) {
    sql += ' WHERE ' + conditions.join(' AND ');
  }

  return { sql, params };
}

// ============================================================================
// Export Utilities
// ============================================================================

/**
 * Export events to CSV format
 */
export function exportEventsToCSV(events: ServerEvent[]): string {
  const headers = [
    'ID',
    'Date/Time',
    'Level',
    'Name',
    'Outcome',
    'User ID',
    'IP Address',
    'Server ID',
    'Attributes',
  ];

  const lines = [headers.join(',')];

  for (const event of events) {
    const row = [
      event.id,
      event.eventTime.toISOString(),
      event.level,
      escapeCSV(event.name),
      event.outcome,
      event.userId,
      event.ipAddress ?? '',
      event.serverId,
      escapeCSV(JSON.stringify(attributesToObject(event.attributes))),
    ];
    lines.push(row.join(','));
  }

  return lines.join('\n');
}

/**
 * Escape a value for CSV output
 */
function escapeCSV(value: string): string {
  if (value.includes(',') || value.includes('"') || value.includes('\n')) {
    return `"${value.replace(/"/g, '""')}"`;
  }
  return value;
}
